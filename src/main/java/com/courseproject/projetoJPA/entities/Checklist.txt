Basic Attributes - private String/Integer/Instant/Double/Long example;

Associations - 1, 1..*, * e 0..1; Começar uma associação quando as duas classes já estiverem sido criadas;

Constructors - public Name() {}
Num2 = public Name(Long id, String name) { this.id = id; this.name = name; }

Getters & Setters(Collections(List): Only get) - Num3 = SetExample, GetExample

HashCode & Equals - Num5 = Função de comparar e não deixar repetir o atributo escolhido

Serializable - implements Serializable, private static final long serialVersionUID = 1L;



<<pk>> = Primary key, as tabelas possuirão a mesma chave primária;
Exemplo: <<pk>> id: Integer = private Long id;

<<enum>> = Normalmente usado em status
Exemplo: WAITING_PAYMENT, PAID, SHIPPED;

orders | *  1 | client = Um cliente poderá ter vários pedidos
Exemplo: Order - @ManyToOne private User client; 
User - @JsonIgnore @OneToMany(mappedBy = "client") private List<Order> orders = new ArrayList<>(); + getOrders;

products | *  1..* | categories = Cada produto pode ter várias categorias e cada categoria pode ter vários produtos
Exemplo: Product - 	@ManyToMany(mappedBy = "products") private Set<Category> categories = new HashSet<>(); + getCategories;
Category - @ManyToMany @JoinTable(name = "tb_product_category", joinColumns = @JoinColumn(name = "category_id"), inverseJoinColumns = @JoinColumn(name = "product_id"))
private Set<Product> products = new HashSet<>(); + getProducts;

---- classe pontilhada no meio de uma ligação entre duas classes = criar subpasta .pk e montar a classe com:
@Embeddable, Serializable, @ManyToOne e @JoinColumn em cima dos atributos, Getters and Setters e HashCode com as duas classes
Usar a chave primária com o atributo da classe .pk na classe principal entre as duas classes (Ex: OrderItemPK e OrderItem)

order | 1  0..1 | payment = 1 pedido tem 1 pagamento e 1 pagamento tem 1 pedido
Payment = @OneToOne @MapsId private Order order;
Order = @OneToOne(mappedBy = "order", cascade = CascadeType.ALL) private Payment payment; + getPayment e setPayment